<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[HITCaiDog's Blog]]></title>
  <subtitle><![CDATA[平常心,平常心！！！]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://HITCaiDog.me/"/>
  <updated>2016-01-24T14:49:40.119Z</updated>
  <id>http://HITCaiDog.me/</id>
  
  <author>
    <name><![CDATA[HITCaiDog]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[urllib2模块、cookielib模块及模拟登录]]></title>
    <link href="http://HITCaiDog.me/2016/01/24/urllib2%E6%A8%A1%E5%9D%97%E3%80%81cookielib%E6%A8%A1%E5%9D%97%E5%8F%8A%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/"/>
    <id>http://HITCaiDog.me/2016/01/24/urllib2模块、cookielib模块及模拟登录/</id>
    <published>2016-01-24T11:53:16.000Z</published>
    <updated>2016-01-24T14:49:40.119Z</updated>
    <content type="html"><![CDATA[<h1 id="urllib2_u6A21_u5757"><a href="#urllib2_u6A21_u5757" class="headerlink" title="urllib2模块"></a>urllib2模块</h1><p>urllib2模块与urllib模块类似，用来打开URL并从中获取数据。与urllib模块不同的是，urllib2不仅可以使用urlopen()函数还可以自定义Opener来访问网页，因此它可以处理更复杂URL的打开问题，一个例子就是有基本认证（用户名和密码）需求的Web站点。</p>
<blockquote>
<p>注意：urlretrieve()函数是urllib模块中的，且urllib2中不存在。但是使用urllib2时一般离不开urllib模块，因为POST的数据需要使用urllib.urlencode()函数来编码。</p>
</blockquote>
<h2 id="urlopen_28_29"><a href="#urlopen_28_29" class="headerlink" title="urlopen()"></a>urlopen()</h2><h3 id="u57FA_u672C_u4ECB_u7ECD"><a href="#u57FA_u672C_u4ECB_u7ECD" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>urlopen()打开一个给定的URL字符串与Web连接，并返回文件类的对象，是最简单的请求方式。</p>
<pre><code>urlopen(url[,data[,timeout]])
</code></pre><blockquote>
<p>其中url可以是url字符串，也可以是urllib2.Request类的实例。</p>
<p>data是经过编码的POST数据(一般使用urllib.urlencode()进行编码)。</p>
<p>timeout是可选的超时设置(单位：秒)，只对HTTP、HTTPS、FTP、FTPS有效。通过urlopen()函数是设置超时时间的最简单的方式，还可以通过socket模块或urllib2模块设置</p>
</blockquote>
<p>urlopen()一旦连接成功，将会返回一个文件类型对象，就像在目标路径打开了一个可读文件。假设文件对象是f，则其将支持可读方法，如f.read()、f.readline()、f.readlines()、f.close()、f.fileno()。</p>
<pre><code>f.read([nbytes])     以字符串形式读取全部或nbytes个字节的数据
f.readline()         以字符串形式读取单行数据
f.readlines()        读取所有行并返回列表
f.fileno()           返回文件句柄(整数描述符)
f.close()            关闭URL连接
f.info()             返回映射对象，带有与URL关联的元信息。对HTTP来讲，返回的服务器响应包含HTTP报头。对于FTP来说，返回的报头包含&apos;content-length&apos;，对于本地文件来说，返回的报头包含&apos;content-length&apos;和&apos;content-type&apos;字段
f.getcode()          返回整型HTTP响应代码，例如，成功时返回200，未找到文件返回404
f.geturl()           返回所返回数据的真实URL
</code></pre><h3 id="u51E0_u5904_u5B9E_u4F8B_u89E3_u6790_uFF1A"><a href="#u51E0_u5904_u5B9E_u4F8B_u89E3_u6790_uFF1A" class="headerlink" title="几处实例解析："></a>几处实例解析：</h3><pre><code>import urllib2

response = urllib2.urlopen(&apos;http://www.douban.com&apos;)
html = response.read()
</code></pre><p>其中<code>response = urllib2.urlopen(&#39;http://www.douban.com&#39;)</code>实际上也可以看作：</p>
<pre><code>request = urllib2.Request(&quot;http://www.douban.com&quot;)
response = urllib2.urlopen(request)
</code></pre><p>POST:</p>
<pre><code>import urllib
import urllib2

url = &apos;http://www.douban.com&apos;
info = {&apos;name&apos;:&apos;username&apos;,&apos;location&apos;:&apos;China&apos;}
data = urllib.urlencode(info)
request = urllib2.Request(url, data)
response = urllib2.urlopen(request)
page = response.read()
</code></pre><p>伪装浏览器：</p>
<pre><code>import urllib
import urllib2

url = &apos;http://www.douban.com&apos;
user_agent = &apos;Mozilla/5.0 (Windows NT 6.1; WOW64)&apos;
values = {&apos;name&apos;:&apos;username&apos;,&apos;location&apos;:&apos;China&apos;}
header = {&apos;User-Agent&apos;:user_agent}

data = urllib.urlencode(values)
request = urllib2.Request(url, data, header)
response = urllib2.urlopen(request)
page = response.read()
</code></pre><h2 id="u81EA_u5B9A_u4E49Opener"><a href="#u81EA_u5B9A_u4E49Opener" class="headerlink" title="自定义Opener"></a>自定义Opener</h2><h3 id="u57FA_u672C_u4ECB_u7ECD-1"><a href="#u57FA_u672C_u4ECB_u7ECD-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>urllib2模块最强大的部分莫过于其的Opener，基本的urlopen()函数不支持验证、Cookie或其它HTTP高级功能。而通过build_opener()函数建立自定义Opener对象则可以支持这些功能。</p>
<pre><code>build_opener([handler1 [, handler2, ……]])
</code></pre><p>要打开URL，可构建自定义opener对象。参数handler1、handler2……都是特殊处理程序对象的实例。这些处理程序的目的是向得到的opener对象添加各种功能。可用的处理程序对象如下所示：</p>
<pre><code>CacheFTPHandler         具有持久FTP连接的FTP处理程序
FileHandler             打开本地文件
FTPHandler              通过FTP打开URL
HTTPBasicAuthHandler    基本的HTTP验证处理
HTTPCookieProcessor     处理HTTP Cookie
HTTPDefaultErrorHandler 通过引发HTTPError异常来处理HTTP错误
HTTPDigestAuthHandler   HTTP摘要验证处理
HTTPHandler             通过HTTP打开URL
HTTPRedirectHandler     处理HTTP重定向
HTTPSHandler            通过安全HTTP打开URL
ProxyHandler            通过代理重定向请求
ProxyBasicAuthHandler   基本的代理验证
ProxyDigestAuthHandler  摘要代理验证
UnknownHandler          处理所有未知URL的处理程序
</code></pre><blockquote>
<p>build_opener()返回的对象具有open(url[, data[, timeout]])方法，作用是根据各种处理程序提供的规则打开URL。</p>
</blockquote>
<pre><code>install_opener(opener)
</code></pre><p>安装opener作为urlopen()使用的全局URL opener，即意味着以后调用urlopen()时都会使用安装的opener对象。opener通常是build_opener()创建的opener对象。</p>
<h3 id="u51E0_u79CD_u76F8_u5BF9_u590D_u6742_u60C5_u51B5_u7684_u89E3_u51B3_u65B9_u6CD5"><a href="#u51E0_u79CD_u76F8_u5BF9_u590D_u6742_u60C5_u51B5_u7684_u89E3_u51B3_u65B9_u6CD5" class="headerlink" title="几种相对复杂情况的解决方法"></a>几种相对复杂情况的解决方法</h3><h4 id="cookie_u5904_u7406_uFF1A"><a href="#cookie_u5904_u7406_uFF1A" class="headerlink" title="cookie处理："></a>cookie处理：</h4><p>如果要管理HTTP cookie，需要创建添加了HTTPCookieProcessor处理程序的opener对象。默认情况下，HTTPCookieProcessor使用CookieJar对象，将不同类型的CookieJar对象作为HTTPCookieProcessor的参数提供，可支持不同的cookie处理。</p>
<pre><code>cookie = cookielib.MozillaCookieJar()
cookiehand = HTTPCookieProcessor(cookie)
opener = urllib2.build_opener(cookiehand)
u = opener.open(url)
</code></pre><h4 id="u5BC6_u7801_u9A8C_u8BC1"><a href="#u5BC6_u7801_u9A8C_u8BC1" class="headerlink" title="密码验证"></a>密码验证</h4><pre><code>import urllib2

auth = urllib2.HTTPBasicAuthHandler()
auth.add_password(realm, url, username, passwd) #realm是与验证相关联的名称或描述信息(如:Administrator)，取决于服务器。
opener = urllib2.build_opener(auth)
u = opener.open(URL)
</code></pre><h4 id="u4EE3_u7406"><a href="#u4EE3_u7406" class="headerlink" title="代理"></a>代理</h4><p>urllib2会自动检测代理设置，默认使用环境变量http_proxy来设置HTTP Proxy。通常情况下是有帮助的，但是某些情况下也可能会造成一些麻烦（因为通过代理获取本地URL资源时会被阻止，因此如果正在通过代理访问internet，则使用脚本测试本地服务器时必须阻止urllib2模块使用代理）。因此，如果想在程序中明确Proxy的使用而不受环境变量的影响，可以创建ProxyHandler实例，并将实例作为build_opener()的参数来实现。</p>
<pre><code>import urllib2

enable_proxy = True
proxy_handler = urllib2.ProxyHandler({&apos;http&apos;:&apos;http://some-proxy.com:8080&apos;})
null_proxy_handler = urllib2.ProxyHandler({})

if enable_proxy:
    opener = urllib2.build_opener(proxy_handler)
else:
    opener = urllib2.build_opener(null_proxy_handler)

urllib2.install_opener(opener)
</code></pre><h1 id="cookielib_u6A21_u5757"><a href="#cookielib_u6A21_u5757" class="headerlink" title="cookielib模块"></a>cookielib模块</h1><p>cookielib模块的主要作用是提供可存储cookie的对象，以便于与urllib2模块配合使用来访问internet资源。例如可以利用本模块的CookieJar类的对象来捕获cookie并在后续连接请求是重新改送。cookielib模块用到的对象主要有以下几个：CookieJar、FileCookieJar、MozillaCookieJar、LWPCookieJar。关系如下：</p>
<p><img src="http://i.imgur.com/mHU9T66.png" alt=""></p>
<h2 id="CookieJar_28_29"><a href="#CookieJar_28_29" class="headerlink" title="CookieJar()"></a>CookieJar()</h2><p>管理HTTP cookie值、存储HTTP请求生成的cookie、向传出的HTTP请求添加cookie的对象。整个cookie都存储在内存中，对CookieJar实例进行垃圾回收后cookie也将丢失。</p>
<h2 id="FileCookieJar_28filename_2C_delayload__3D_None_2C_policy__3D_None_29"><a href="#FileCookieJar_28filename_2C_delayload__3D_None_2C_policy__3D_None_29" class="headerlink" title="FileCookieJar(filename, delayload = None, policy = None)"></a>FileCookieJar(filename, delayload = None, policy = None)</h2><p>创建FileCookieJar实例，检索cookie信息并将cookie存储到文件中。filename是存储cookie的文件名。delayload为True时支持延迟访问文件，即只有在需要时才读文件或在文件中存储数据。</p>
<h2 id="MozillaCookieJar_28filename_2C_delayload__3D_None_2C_policy__3D_None_29"><a href="#MozillaCookieJar_28filename_2C_delayload__3D_None_2C_policy__3D_None_29" class="headerlink" title="MozillaCookieJar(filename, delayload = None, policy = None)"></a>MozillaCookieJar(filename, delayload = None, policy = None)</h2><p>创建与Mozilla浏览器cookies.txt兼容的FileCookieJar实例。</p>
<h2 id="LWPCookieJar_28filename_2C_delayload__3D_None_2C_policy__3D_None_29"><a href="#LWPCookieJar_28filename_2C_delayload__3D_None_2C_policy__3D_None_29" class="headerlink" title="LWPCookieJar(filename, delayload = None, policy = None)"></a>LWPCookieJar(filename, delayload = None, policy = None)</h2><p>创建与libwww-per的Set-Cookie3文件格式兼容的FileCookieJar实例。</p>
<h1 id="u6A21_u62DF_u767B_u5F55_u5B9E_u4F8B"><a href="#u6A21_u62DF_u767B_u5F55_u5B9E_u4F8B" class="headerlink" title="模拟登录实例"></a>模拟登录实例</h1><pre><code>#! /usr/bin/env python
#coding=utf-8
import urllib2
import urllib
import cookielib

data = {&quot;email&quot;: &quot;username&quot;, &quot;password&quot;: &quot;passwd&quot;}  #登陆用户名和密码
post_data = urllib.urlencode(data)
cookie = cookielib.CookieJar()
opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cookie))
headers = {&quot;User-agent&quot;:&quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1&quot;}
request = urllib2.Request(&quot;http://www.renren.com/PLogin.do&quot;,post_data,headers)
content = opener.open(req)
print content.read().decode(&quot;utf-8&quot;).encode(&quot;gbk&quot;)
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="urllib2_u6A21_u5757"><a href="#urllib2_u6A21_u5757" class="headerlink" title="urllib2模块"></a>urllib2模块</h1><p>urllib2模块与urllib模块类似，用]]>
    </summary>
    
      <category term="cookielib" scheme="http://HITCaiDog.me/tags/cookielib/"/>
    
      <category term="python" scheme="http://HITCaiDog.me/tags/python/"/>
    
      <category term="urllib2" scheme="http://HITCaiDog.me/tags/urllib2/"/>
    
      <category term="爬虫" scheme="http://HITCaiDog.me/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="python" scheme="http://HITCaiDog.me/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Git常用命令]]></title>
    <link href="http://HITCaiDog.me/2016/01/23/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://HITCaiDog.me/2016/01/23/Git常用命令/</id>
    <published>2016-01-23T03:24:07.000Z</published>
    <updated>2016-01-23T11:21:08.123Z</updated>
    <content type="html"><![CDATA[<p>转自<a href="http://notes.xiamo.tk/2015-06-29-Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html" target="_blank" rel="external">夏末’S NOTE</a></p>
<h2 id="u57FA_u672C_u914D_u7F6E_u547D_u4EE4"><a href="#u57FA_u672C_u914D_u7F6E_u547D_u4EE4" class="headerlink" title="基本配置命令"></a>基本配置命令</h2><h3 id="Git_u5E38_u7528_u547D_u4EE4_u901F_u67E5_u8868"><a href="#Git_u5E38_u7528_u547D_u4EE4_u901F_u67E5_u8868" class="headerlink" title="Git常用命令速查表"></a>Git常用命令速查表</h3><p><img src="http://i.imgur.com/dHE4dkR.jpg" alt=""><br><a id="more"></a></p>
<h3 id="u4F7F_u7528Git_u751F_u6210ssh_u5BC6_u94A5"><a href="#u4F7F_u7528Git_u751F_u6210ssh_u5BC6_u94A5" class="headerlink" title="使用Git生成ssh密钥"></a>使用Git生成ssh密钥</h3><pre><code>ssh-keygen -t rsa -C &quot;email@example.com&quot;
</code></pre><h3 id="u8BBE_u7F6E_u5168_u5C40_u7528_u6237_u540D_u548C_u90AE_u7BB1"><a href="#u8BBE_u7F6E_u5168_u5C40_u7528_u6237_u540D_u548C_u90AE_u7BB1" class="headerlink" title="设置全局用户名和邮箱"></a>设置全局用户名和邮箱</h3><pre><code>git config --global user.name &quot;YourName&quot;
git config --global user.email &quot;email@example.com&quot;
</code></pre><h3 id="u521D_u59CB_u5316_u4ED3_u5E93"><a href="#u521D_u59CB_u5316_u4ED3_u5E93" class="headerlink" title="初始化仓库"></a>初始化仓库</h3><pre><code>git init
</code></pre><h3 id="u6DFB_u52A0_u6587_u4EF6_u5230_u6682_u5B58_u533A"><a href="#u6DFB_u52A0_u6587_u4EF6_u5230_u6682_u5B58_u533A" class="headerlink" title="添加文件到暂存区"></a>添加文件到暂存区</h3><pre><code>git add &lt;filename&gt;    #添加指定文件到暂存区
git add .    #添加工作区所有文件到暂存区
git add -i    #交互方式添加文件到暂存区
git add -u    #将工作区中已经变动的文件添加到暂存区，当新增加的文件不会被添加
</code></pre><h3 id="u63D0_u4EA4_u6587_u4EF6_u5230_u4ED3_u5E93"><a href="#u63D0_u4EA4_u6587_u4EF6_u5230_u4ED3_u5E93" class="headerlink" title="提交文件到仓库"></a>提交文件到仓库</h3><pre><code>git commit -m &quot;描述信息&quot;        #提交更新
git commit -am &quot;描述信息&quot;    #如果工作目录中仅是已跟踪的文件被修改或被删除，使用此提交命令
</code></pre><h3 id="u5206_u652F_u7684_u521B_u5EFA_u3001_u5220_u9664_u3001_u548C_u5E73_u3001_u5207_u6362_u3001_u67E5_u770B"><a href="#u5206_u652F_u7684_u521B_u5EFA_u3001_u5220_u9664_u3001_u548C_u5E73_u3001_u5207_u6362_u3001_u67E5_u770B" class="headerlink" title="分支的创建、删除、和平、切换、查看"></a>分支的创建、删除、和平、切换、查看</h3><pre><code>git branch    #查看Git仓库中已有的分支
git branch 新分支名 [分支起点]    #创建分支，如果没有分支起点的话，则默认在当前分支的最新提交上创建分支
git checkout 分支名    #切换分支
git checkout -b 新分支名        #创建同时切换到新分支
git merge 要被合并的分支名    #合并分支
git branch -d 要删除的分支名    #删除指定分支（如果分支没有被合并过，该命令会执行失败）
git branch -D 要删除的分支名    #删除指定分支，不管有没有被合并过
gitk                #用图形界面查看分支提交历史
</code></pre><p>合并分支过程中如果发生冲突则需要自己手动解决冲突，然后再提交。有冲突时，Git会显示哪个文件有冲突，并在冲突的文件中加上特殊的标识符号，解决完冲突后，要手动去掉这些被添加的标识符号。如果冲突比较复杂的话，最好使用其他工具来协助，通过git mergetool来启动。冲突一般是在不同的分支上对同一文件的同一位置内容进行了改动，并已提交到仓库中，这样在合并的时候就会发生冲突。</p>
<h3 id="u6807_u7B7E_u7684_u6DFB_u52A0_u3001_u5220_u9664_u3001_u67E5_u770B"><a href="#u6807_u7B7E_u7684_u6DFB_u52A0_u3001_u5220_u9664_u3001_u67E5_u770B" class="headerlink" title="标签的添加、删除、查看"></a>标签的添加、删除、查看</h3><pre><code>git tag        #查看标签
git tag 标签名    #创建简单的标签
git tag -a 标签名 -m &apos;附加信息&apos;    #创建附加信息的标签
git show 标签名    #通过标签查看信息
git tag -d 标签名    #删除标签
</code></pre><p>标签可以在需要的地方，为某个提交对象创建别名，这样以后我们就可以通过标签来查看一些信息，创建分支等。</p>
<h3 id="u67E5_u770B_u5DE5_u4F5C_u76EE_u5F55_u72B6_u6001"><a href="#u67E5_u770B_u5DE5_u4F5C_u76EE_u5F55_u72B6_u6001" class="headerlink" title="查看工作目录状态"></a>查看工作目录状态</h3><pre><code>git status
</code></pre><p>在git命令执行后，要养成通过git status查看git状态的习惯，以便及时了解文件变化的情况。通过git status可以知道文件的状态（已修改未暂存、已删除、已修改并已暂存等待提交、未跟踪）。</p>
<h3 id="u67E5_u770B_u63D0_u4EA4_u5386_u53F2"><a href="#u67E5_u770B_u63D0_u4EA4_u5386_u53F2" class="headerlink" title="查看提交历史"></a>查看提交历史</h3><pre><code>git log
git log -p    #显示每次提交文件变化
</code></pre><p>通过git log可以查看当前分支的所有提交历史，知道每次提交的commit对象的ID以及提交时附加的描述信息等。要显示更多的信息，需要使用其支持的选项，如git log -p可以将每次提交的文件变化也显示出来。</p>
<h3 id="u67E5_u770B_u6307_u5B9A_u7684_u63D0_u4EA4_u5BF9_u8C61"><a href="#u67E5_u770B_u6307_u5B9A_u7684_u63D0_u4EA4_u5BF9_u8C61" class="headerlink" title="查看指定的提交对象"></a>查看指定的提交对象</h3><pre><code>git show commit_id    #查看指定的某次提交内容
git show --all        #显示所有的提交历史内容
git shortlog -s -n    #显示总的提交次数
</code></pre><p>通过<code>git log</code>可以显示整个提交历史，而通过<code>git show commit-id</code>则可以查看指定的某次提交内容，当然<code>git show -all</code>也可以显示出提交历史，另外还可以格式化显示内容。</p>
<blockquote>
<p>Note : commit-id可以是commit对象对应的ID，也可以是HEAD，分支名，tag等。</p>
</blockquote>
<h3 id="u67E5_u770B_u5DE5_u4F5C_u533A_u3001_u6682_u5B58_u533A_u3001_u4ED3_u5E93_u4E4B_u95F4_u7684_u5DEE_u5F02"><a href="#u67E5_u770B_u5DE5_u4F5C_u533A_u3001_u6682_u5B58_u533A_u3001_u4ED3_u5E93_u4E4B_u95F4_u7684_u5DEE_u5F02" class="headerlink" title="查看工作区、暂存区、仓库之间的差异"></a>查看工作区、暂存区、仓库之间的差异</h3><pre><code>git diff        #比较工作区与暂存区的差异
git diff HEAD        #比较工作区与仓库中最近一次的提交间的差异
git diff --cached    #比较暂存区与仓库中最近一次提交的差异
git blame filename    #可以列出该文件每次被修改的时间和内容
</code></pre><h3 id="u7248_u672C_u56DE_u9000_u3001_u64A4_u9500_u64CD_u4F5C"><a href="#u7248_u672C_u56DE_u9000_u3001_u64A4_u9500_u64CD_u4F5C" class="headerlink" title="版本回退、撤销操作"></a>版本回退、撤销操作</h3><pre><code>git reflog    #显示提交历史的简介
git checkout -- filename    #丢弃工作区的修改
git reset --hard HEAD^        #回退到上一个版本
git reset --hard commit_id    #回退到指定版本
git checkout -- filename    #恢复工作区被删除的指定文件（文件之前被提交到仓库中）
git checkout -f         #恢复工作区中所有被删除的文件(文件之前被提交到仓库中)
git ls-files -d            #列出工作区被删除的文件（文件之前被提交到仓库中）
</code></pre><blockquote>
<p>有时候，由于我们的误操作，产生了一些错误，我们发现后希望能够及时纠正这些因为误操作而产生的结果，将工作目录恢复到某个正常状态。</p>
</blockquote>
<p>撤销修改，但还没有添加到暂存区： <code>git checkout -- filename</code> 修改的文件会被恢复到上次提交时的状态，修改的内容会丢失。<br>版本回退：先通过<code>git reflog</code>找到某个版本的<code>commit_id</code>，然后用<code>git reset --hard commit_id</code>将工作目录的文件恢复到指定的版本。<br>恢复工作区中被删除的文件（文件之前被提交到仓库中）：<code>git checkout -- filename</code> 或 <code>git checkout -f</code></p>
<h3 id="u5907_u4EFD_u5DE5_u4F5C_u533A"><a href="#u5907_u4EFD_u5DE5_u4F5C_u533A" class="headerlink" title="备份工作区"></a>备份工作区</h3><pre><code>git stash            #将工作区文件保存在Git内部栈中
git stash list            #列出Git内部栈中保存的工作区文件列表
git stash apply stash_id    #恢复工作区到指定的内部栈状态
git stash pop            #恢复工作区到上一个内部栈状态
git stash clear            #清空Git内部栈
</code></pre><p>如果正在一个<code>develop</code>分支上正在开发新功能，但这时<code>master</code>分支(稳定版本)突然发现了bug，并需要及时修复，而<code>develop</code>分支此时的工作还没有完成，且不希望将之前的工作就这样提交到仓库中时，这时就可以用<code>git stash</code>来暂时保存这些状态到Git内部栈中，并用当前分支上一次的提交内容来恢复工作目录，然后切换到<code>master</code>分支进行bug修复工作，等修复完毕并提交到仓库上后，再使用<code>git stash apply [stash@{0}]</code>或者<code>git stash pop</code>将工作目录恢复到之前的状态，继续之前的工作。</p>
<p>同时也可以多次使用<code>git stash</code>将未提交的代码压入到Git栈中，但当多次使用<code>git stash</code>命令后，Git栈里将充满了未提交的代码，这时候到底要用哪个版本来恢复工作目录呢？<code>git stash list</code>命令可以将当前的Git栈信息打印出来，我们只需要将找到对应的版本号，例如使用<code>git stash apply stash@{1}</code>就可以用版本号为<code>stash@{1}</code>的内容来恢复工作目录。</p>
<p>当Git栈中所有的内容都被恢复后，可以使用<code>git stash clear</code>来将栈清空。</p>
<h3 id="u5C06_u5F53_u524D_u5DE5_u4F5C_u533A_u76EE_u5F55_u6587_u4EF6_u538B_u7F29_u5F52_u6863"><a href="#u5C06_u5F53_u524D_u5DE5_u4F5C_u533A_u76EE_u5F55_u6587_u4EF6_u538B_u7F29_u5F52_u6863" class="headerlink" title="将当前工作区目录文件压缩归档"></a>将当前工作区目录文件压缩归档</h3><pre><code>git archive --format=zip -o arch.zip HEAD
git arch --format zip head&gt;arch.zip
</code></pre><h2 id="u8FDC_u7A0B_u64CD_u4F5C"><a href="#u8FDC_u7A0B_u64CD_u4F5C" class="headerlink" title="远程操作"></a>远程操作</h2><p>Git相比其他版本控制软件的一个优点就是大多数的操作都可以在本地进行，而不用管远程的仓库，因为操作是在本地，且操作的数据也是在本地，加上指针等原因，所以执行的速度就会比较快。 在多人协作的项目中，就需要涉及与远程仓库交互的问题，主要是如何从远程仓库抓取最新数据合并到自己的本地分支上，将自己的最新成果分享给其他人或让别人审查等 。</p>
<h3 id="u8FDC_u7A0B_u4ED3_u5E93_u7684_u514B_u9686_u3001_u6DFB_u52A0_u3001_u67E5_u770B"><a href="#u8FDC_u7A0B_u4ED3_u5E93_u7684_u514B_u9686_u3001_u6DFB_u52A0_u3001_u67E5_u770B" class="headerlink" title="远程仓库的克隆、添加、查看"></a>远程仓库的克隆、添加、查看</h3><pre><code>git remote    #显示已添加的远程仓库名
git remote -v     #显示已添加的远程仓库名和地址
git remote add 远程仓库名 远程仓库地址    #在本地添加远程仓库
git remote rm 远程仓库名            #删除本地添加的远程仓库名
git remote rename 原名 新名        #重命名远程仓库名
git clone 远程仓库地址 [克隆到指定的文件夹]    #克隆远程仓库到本地
git fetch 远程仓库名        #从远程仓库抓取最新数据到本地但不与本地分支进行合并 
git pull 远程仓库名    本地要合并的分支名    #从远程仓库抓取最新数据并自动与本地分支进行合并
git push 远程仓库名 本地分支名    #将本地仓库推送到远程仓库中
git remote show 远程仓库名    #查看远程仓库信息
git remote show            #查看所有远程仓库
git push 远程仓库名 标签名    #将标签推送到远程仓库（Git默认不推送标签）
</code></pre><h3 id="u534F_u540C_u6D41_u7A0B"><a href="#u534F_u540C_u6D41_u7A0B" class="headerlink" title="协同流程"></a>协同流程</h3><p>Fork远程项目</p>
<p>把Fork的项目clone到本地</p>
<p>执行以下命令，将别人的库添加为远端库</p>
<pre><code>git remote add 远端仓库名 远端的分支
</code></pre><p>运行以下命令，拉去合并到本地</p>
<pre><code>git pull 远端仓库名 远端分支名
</code></pre><p>编辑内容</p>
<p><code>commit</code>之后<code>push</code>到自己的库</p>
<p>登录Github，在你的首页可以看到一个<code>pull request</code>按钮，点击它，填写一些说明信息，提交即可。</p>
<p>在本地编辑内容前必须执行<code>pull</code>操作同步别人的远端库（这样避免冲突）</p>
<h3 id="u5B9E_u7528_u6280_u5DE7"><a href="#u5B9E_u7528_u6280_u5DE7" class="headerlink" title="实用技巧"></a>实用技巧</h3><p>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再使用<code>git stash pop</code>，回到工作现场.</p>
<h3 id="u591A_u4EBA_u534F_u4F5C_u6280_u5DE7"><a href="#u591A_u4EBA_u534F_u4F5C_u6280_u5DE7" class="headerlink" title="多人协作技巧"></a>多人协作技巧</h3><p>查看远程库信息，使用<code>git remote -v</code>；</p>
<p>本地新建的分支如果不推送到远程，对其他人就是不可见的；</p>
<p>从本地推送分支，使用<code>git push</code> 远程仓库名 分支名，如果推送失败，先用<code>git pull</code>抓取远程的新提交；</p>
<p>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</p>
<p>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</p>
<p>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</p>
<h3 id="Git_u5E38_u7528_u547D_u4EE4_u601D_u7EF4_u5BFC_u56FE"><a href="#Git_u5E38_u7528_u547D_u4EE4_u601D_u7EF4_u5BFC_u56FE" class="headerlink" title="Git常用命令思维导图"></a>Git常用命令思维导图</h3><p><img src="http://i.imgur.com/Jbr9CJ6.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>转自<a href="http://notes.xiamo.tk/2015-06-29-Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html">夏末’S NOTE</a></p>
<h2 id="u57FA_u672C_u914D_u7F6E_u547D_u4EE4"><a href="#u57FA_u672C_u914D_u7F6E_u547D_u4EE4" class="headerlink" title="基本配置命令"></a>基本配置命令</h2><h3 id="Git_u5E38_u7528_u547D_u4EE4_u901F_u67E5_u8868"><a href="#Git_u5E38_u7528_u547D_u4EE4_u901F_u67E5_u8868" class="headerlink" title="Git常用命令速查表"></a>Git常用命令速查表</h3><p><img src="http://i.imgur.com/dHE4dkR.jpg" alt=""><br>]]>
    
    </summary>
    
      <category term="Git" scheme="http://HITCaiDog.me/tags/Git/"/>
    
      <category term="Git" scheme="http://HITCaiDog.me/categories/Git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TLS协议握手过程]]></title>
    <link href="http://HITCaiDog.me/2016/01/22/TLS%E5%8D%8F%E8%AE%AE%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/"/>
    <id>http://HITCaiDog.me/2016/01/22/TLS协议握手过程/</id>
    <published>2016-01-22T12:33:26.000Z</published>
    <updated>2016-01-23T03:32:13.614Z</updated>
    <content type="html"><![CDATA[<h2 id="TLS_u63E1_u624B_u6574_u4E2A_u8FC7_u7A0B"><a href="#TLS_u63E1_u624B_u6574_u4E2A_u8FC7_u7A0B" class="headerlink" title="TLS握手整个过程"></a>TLS握手整个过程</h2><p><img src="http://i.imgur.com/bEyG2V7.png" alt=""></p>
<h2 id="Client_Hello"><a href="#Client_Hello" class="headerlink" title="Client Hello"></a>Client Hello</h2><p>这是TLS握手的第一步，由客户端发起请求。此协议主要包括了一个客户端生成的随机字符串（用来下面生成session key），还有客户端支持的加密套件列表。<a id="more"></a>如图：</p>
<p><img src="http://i.imgur.com/ObZObBx.png" alt=""></p>
<h2 id="Server_Hello"><a href="#Server_Hello" class="headerlink" title="Server Hello"></a>Server Hello</h2><p>服务器收到客户端的Client Hello数据包之后，根据客户端发来的加密套件列表，选择一个加密套件，也生成一个随机字符串返回给客户端。我们看到下图中的加密套件为，密钥交换算法使用ECDHE_RSA，对称加密算法使用AES_256_GCM_SHA384,如图：</p>
<p><img src="http://i.imgur.com/Dv9xmKd.png" alt=""></p>
<h2 id="Server_Certificate"><a href="#Server_Certificate" class="headerlink" title="Server Certificate"></a>Server Certificate</h2><p>接着服务器再返回证书列表，包括证书链及域名证书。返回的证书用来给客户端验证当前连接服务器的身份，防止中间人攻击。</p>
<p>##Server Key Exchange</p>
<p>Server Key Exchange协议包，由服务器返回，主要目的是与客户端交换用于数据对称加密的密钥。如图：</p>
<p><img src="http://i.imgur.com/D8ga0P9.png" alt=""></p>
<h2 id="Server_Hello_Done"><a href="#Server_Hello_Done" class="headerlink" title="Server Hello Done"></a>Server Hello Done</h2><p>服务器返回此协议数据，告诉客户端已经完成返回所需用于密钥交换的数据。服务器等待客户端响应。</p>
<h2 id="Client_Key_Exchange"><a href="#Client_Key_Exchange" class="headerlink" title="Client Key Exchange"></a>Client Key Exchange</h2><p>客户端根据服务器返回的DH密钥数据生成DH公共数据也发给服务器，用来生成最终的pre-master-secret。如图：</p>
<p><img src="http://i.imgur.com/KAhvJiD.png" alt=""></p>
<h2 id="Change_Cipher_Spec"><a href="#Change_Cipher_Spec" class="headerlink" title="Change Cipher Spec"></a>Change Cipher Spec</h2><p>此协议用于客户端和服务器相互告知也完成密钥交换过程，可以切换到对称加密过程。<br>到这里大概的TLS握手过程就结束了。为解决本文中的问题，还需要了解密钥交换的算法，RSA和Diffie–Hellman。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="TLS_u63E1_u624B_u6574_u4E2A_u8FC7_u7A0B"><a href="#TLS_u63E1_u624B_u6574_u4E2A_u8FC7_u7A0B" class="headerlink" title="TLS握手整个过程"></a>TLS握手整个过程</h2><p><img src="http://i.imgur.com/bEyG2V7.png" alt=""></p>
<h2 id="Client_Hello"><a href="#Client_Hello" class="headerlink" title="Client Hello"></a>Client Hello</h2><p>这是TLS握手的第一步，由客户端发起请求。此协议主要包括了一个客户端生成的随机字符串（用来下面生成session key），还有客户端支持的加密套件列表。]]>
    
    </summary>
    
      <category term="TLS" scheme="http://HITCaiDog.me/tags/TLS/"/>
    
      <category term="协议分析" scheme="http://HITCaiDog.me/tags/%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"/>
    
      <category term="协议" scheme="http://HITCaiDog.me/categories/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Birthday]]></title>
    <link href="http://HITCaiDog.me/2015/12/31/Birthday/"/>
    <id>http://HITCaiDog.me/2015/12/31/Birthday/</id>
    <published>2015-12-31T12:41:04.000Z</published>
    <updated>2016-01-23T03:32:15.182Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">HITCaiDog’s Blog</a>! This is my very first post. There are some important steps listed as follows. </p>
<h2 id="Preparation_28For_Windows_29"><a href="#Preparation_28For_Windows_29" class="headerlink" title="Preparation(For Windows)"></a>Preparation(For Windows)</h2><p><a href="http://nodejs.org/" target="_blank" rel="external">node.js</a></p>
<p><a href="http://git-scm.com/" target="_blank" rel="external">git</a></p>
<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><h3 id="Run_Git_CMD_2Cinput"><a href="#Run_Git_CMD_2Cinput" class="headerlink" title="Run Git CMD,input"></a>Run Git CMD,input</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Enter_the_directory_you_want_to_store_hexo_28such_as_E_3A_5Chexo_29_2Cthen_input"><a href="#Enter_the_directory_you_want_to_store_hexo_28such_as_E_3A_5Chexo_29_2Cthen_input" class="headerlink" title="Enter the directory you want to store hexo(such as E:\hexo),then input"></a>Enter the directory you want to store hexo(such as E:\hexo),then input</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<p>Hexo will automatically create all the files needed for the site in the target folder.</p>
<h3 id="Change_theme_28not_essential_29"><a href="#Change_theme_28not_essential_29" class="headerlink" title="Change theme(not essential)"></a>Change theme(not essential)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next.git themes/hexo-theme-next</span><br></pre></td></tr></table></figure>
<p>Modify the config.yml under the directory of Hexo,change the value of theme to hexo-theme-next.</p>
<p>Maybe useful:(update the theme file)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> theme/hexo-theme-next</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>
<h3 id="Generation"><a href="#Generation" class="headerlink" title="Generation"></a>Generation</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate \\(or hexo g),generate the <span class="built_in">local</span> blog files.</span><br><span class="line">hexo server \\(or hexo s),start the <span class="built_in">local</span> server <span class="keyword">for</span> testing purposes.</span><br></pre></td></tr></table></figure>
<p>You can preview on <a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a></p>
<h2 id="Register_on_Github"><a href="#Register_on_Github" class="headerlink" title="Register on Github"></a><a href="http://www.github.com/" target="_blank" rel="external">Register on Github</a></h2><p>Register a new account.</p>
<p>Build a repository named “username.github.io”</p>
<h2 id="SSH_Keys_28By_GitBash_29"><a href="#SSH_Keys_28By_GitBash_29" class="headerlink" title="SSH Keys(By GitBash)"></a>SSH Keys(By GitBash)</h2><h3 id="u68C0_u67E5_u7535_u8111_u4E0A_u73B0_u6709_u7684SSH_Keys"><a href="#u68C0_u67E5_u7535_u8111_u4E0A_u73B0_u6709_u7684SSH_Keys" class="headerlink" title="检查电脑上现有的SSH Keys"></a>检查电脑上现有的SSH Keys</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br></pre></td></tr></table></figure>
<p>如果显示”No such file or directory”，则进入第三步，否则继续。</p>
<h3 id="u5907_u4EFD_u548C_u79FB_u9664_u539F_u6765_u7684SSH_Keys_u8BBE_u7F6E"><a href="#u5907_u4EFD_u548C_u79FB_u9664_u539F_u6765_u7684SSH_Keys_u8BBE_u7F6E" class="headerlink" title="备份和移除原来的SSH Keys设置"></a>备份和移除原来的SSH Keys设置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br><span class="line">config  id_rsa  id_rsa.pub  known_hosts</span><br><span class="line">mkdir key_backup</span><br><span class="line">cp id_rsa* key_backup</span><br><span class="line">rm id_rsa*</span><br></pre></td></tr></table></figure>
<h3 id="u751F_u6210_u65B0_u7684SSH_Keys"><a href="#u751F_u6210_u65B0_u7684SSH_Keys" class="headerlink" title="生成新的SSH Keys"></a>生成新的SSH Keys</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"yourmail@mail.com"</span></span><br></pre></td></tr></table></figure>
<p>后续操作按提示完成即可(输入加密串后布署失败，为空时布署成功)。</p>
<h3 id="u6DFB_u52A0SSH_Keys_u5230Github"><a href="#u6DFB_u52A0SSH_Keys_u5230Github" class="headerlink" title="添加SSH Keys到Github"></a>添加SSH Keys到Github</h3><p>在本机设置SSH Keys后，需要添加到Github上，以完成SSH链接的设置。</p>
<p>复制刚刚生成的密钥文件id_rsa.pub的内容，粘贴到Github上用户设置-SSH Keys中Add Key。</p>
<h3 id="u6D4B_u8BD5"><a href="#u6D4B_u8BD5" class="headerlink" title="测试"></a>测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<h3 id="u8BBE_u7F6E_u5E10_u53F7_u4FE1_u606F"><a href="#u8BBE_u7F6E_u5E10_u53F7_u4FE1_u606F" class="headerlink" title="设置帐号信息"></a>设置帐号信息</h3><p>Git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字必须是你的真名，而不是GitHub的昵称。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"yourname"</span></span><br><span class="line">git config --global user.email <span class="string">"yourmail@mail.com"</span></span><br></pre></td></tr></table></figure>
<h2 id="u90E8_u7F72_u5230Github"><a href="#u90E8_u7F72_u5230Github" class="headerlink" title="部署到Github"></a>部署到Github</h2><p>配置hexo中的配置文件：_config.yml</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    <span class="built_in">type</span>: git</span><br><span class="line">    repository: git@github.com:用户名/用户名.github.com.git</span><br><span class="line">    (我的:repository:git@github.com:BigCaiDog/BigCaiDog.github.com.git)</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure>
<p>然后执行命令：</p>
<figure class="highlight"><figcaption><span>clean</span><a href="//清除缓存">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate&#10;hexo deploy //&#24067;&#32626;</span><br></pre></td></tr></table></figure>
<p>此时，在博客的根目录下会生成一个文件夹：.deploy</p>
<p>然后我们把这个文件夹里面的文件都push到刚才新建那个项目就OK了。几分钟过后，就可以打开你的用户名.github.io看到你的博客了。</p>
<h2 id="u6DFB_u52A0_u65B0_u6587_u7AE0"><a href="#u6DFB_u52A0_u65B0_u6587_u7AE0" class="headerlink" title="添加新文章"></a>添加新文章</h2><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="string">"name"</span></span><br></pre></td></tr></table></figure>
<p>编辑name.md文件并保存，重新生成布置即可。</p>
<h2 id="u7ED1_u5B9A_u57DF_u540D"><a href="#u7ED1_u5B9A_u57DF_u540D" class="headerlink" title="绑定域名"></a>绑定域名</h2><p>方法一：在Repository的根目录下面，新建一个名为CNAME的文本文件，里面写入你要绑定的域名，比如cnfeat.com。</p>
<p>方法二：到我的github仓库，点击右下角的「Download ZIP」，下载源文件，解压，找到CNAME文件，用记事本打开，将cnfeat.com修改成你的域名，放进Hexo\source目录下，用hexo命令提交上去。</p>
<h3 id="DNS_u8BBE_u7F6E"><a href="#DNS_u8BBE_u7F6E" class="headerlink" title="DNS设置"></a>DNS设置</h3><p>用DNSpod，快，免费，稳定。</p>
<p>注册DNSpod，添加域名，如下图设置。</p>
<p><img src="http://i.imgur.com/a0fiGO8.png" alt=""></p>
<p>其中A的两条记录指向的ip地址是github Pages的提供的ip</p>
<p>192.30.252.153</p>
<p>192.30.252.154</p>
<p>如博客不能登录，有可能是github更改了空间服务的ip地址，记得及时到在<a href="https://help.github.com/articles/setting-up-a-custom-domain-with-github-pages/" target="_blank" rel="external">GitHub Pages</a>查看最新的ip即可</p>
<p>www指定的记录是你在github注册的仓库。</p>
<h3 id="u53BBGodaddy_u4FEE_u6539DNS_u5730_u5740"><a href="#u53BBGodaddy_u4FEE_u6539DNS_u5730_u5740" class="headerlink" title="去Godaddy修改DNS地址"></a>去Godaddy修改DNS地址</h3><p>更改godaddy的Nameservers为DNSpod的NameServers。</p>
<p><img src="http://i.imgur.com/LPZqQHc.jpg" alt=""></p>
<p><img src="http://i.imgur.com/ey7jqjH.png" alt=""></p>
<h2 id="u5B89_u88C5_u63D2_u4EF6"><a href="#u5B89_u88C5_u63D2_u4EF6" class="headerlink" title="安装插件"></a>安装插件</h2><p>添加sitemap和feed插件</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-generator-sitemap</span><br><span class="line">npm <span class="keyword">install</span> hexo-generator-feed</span><br></pre></td></tr></table></figure>
<p>修改_config.yml，增加以下内容</p>
<h3 id="Extensions"><a href="#Extensions" class="headerlink" title="Extensions"></a>Extensions</h3><p>Plugins:</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> hexo-generator-feed</span><br><span class="line"></span>-<span class="ruby"> hexo-generator-sitemap</span></span><br></pre></td></tr></table></figure>
<h3 id="Feed_Atom"><a href="#Feed_Atom" class="headerlink" title="Feed Atom"></a>Feed Atom</h3><p>feed:</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">type</span>: <span class="string">atom</span></span><br><span class="line"><span class="attribute">path</span>: <span class="string">atom.xml</span></span><br><span class="line"><span class="attribute">limit</span>: <span class="string">20</span></span><br></pre></td></tr></table></figure>
<h3 id="sitemap"><a href="#sitemap" class="headerlink" title="sitemap"></a>sitemap</h3><p>sitemap:</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">path</span>: <span class="string">sitemap.xml</span></span><br></pre></td></tr></table></figure>
<p>Hexo上传README文件</p>
<p>Github的版本库通常建议同时附上README.md说明文件，但是hexo默认情况下会把所有md文件解析成html文件，所以即使你在线生成了README.md，它也会在你下一次部署时被删去。怎么解决呢？</p>
<p>在执行hexo deploy前把在本地写好的README.md文件复制到.deploy文件夹中，再去执行hexo deploy。</p>
<h3 id="404_u9875_u9762"><a href="#404_u9875_u9762" class="headerlink" title="404页面"></a>404页面</h3><p>GitHub Pages有提供制作404页面的指引：<a href="https://help.github.com/articles/custom-404-pages/" target="_blank" rel="external">Custom 404 Pages</a>。</p>
<p>直接在根目录下创建自己的404.html或者404.md就可以。但是自定义404页面仅对绑定顶级域名的项目才起作用，GitHub默认分配的二级域名是不起作用的，使用hexo server在本机调试也是不起作用的。</p>
<p>推荐使用<a href="http://www.qq.com/404/" target="_blank" rel="external">腾讯公益404</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Welcome to <a href="http://hexo.io/">HITCaiDog’s Blog</a>! This is my very first post. There are some important steps listed as follows. </p>
<h2 id="Preparation_28For_Windows_29"><a href="#Preparation_28For_Windows_29" class="headerlink" title="Preparation(For Windows)"></a>Preparation(For Windows)</h2><p><a href="http://nodejs.org/">node.js</a></p>
<p><a href="http://git-scm.com/">git</a></p>
<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><h3 id="Run_Git_CMD_2Cinput"><a href="#Run_Git_CMD_2Cinput" class="headerlink" title="Run Git CMD,input"></a>Run Git CMD,input</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Random" scheme="http://HITCaiDog.me/tags/Random/"/>
    
      <category term="教程" scheme="http://HITCaiDog.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="随笔" scheme="http://HITCaiDog.me/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
